---
title: FreeRTOS interview questions
date: 2024-05-24 16:20:42 +0800
categories: [CS, FreeRTOS]
tags: [freertos, interview]    # TAG names should always be **lowercase**
---

## 相关面试问题

1. FreeRTOS的任务有哪些状态？

   - 就绪（Ready）：该任务在就绪列表中，就绪的任务已经具备执行的能力，只等待调度器进行调度，新创建的任务会初始化为就绪态。

   - 运行（Running）：该状态表明任务正在执行，此时它占用处理器，FreeRTOS调度器选择运行的永远是处于最高优先级的就绪态任务，当任务被运行的一刻，它的任务状态就变成了运行态。

   - 阻塞（Blocked）：如果任务当前正在等待某个时序或外部中断，我们就说这个任务处于阻塞状态，该任务不在就绪列表中。包含任务被挂起、任务被延时、任务正在等待信号量、读写队列或者等待读写事件等。

   - 挂起态(Suspended)：处于挂起态的任务对调度器而言是不可见的，让一个任务进入挂起状态的唯一办法就是调用 vTaskSuspend()函数；而把一个挂起状态的任务恢复的唯一途径就是调用 vTaskResume()或vTaskResumeFromISR()函数，我们可以这么理解挂起态与阻塞态的区别，当任务有较长的时间不允许运行的时候，我们可以挂起任务，这样子调度器就不会管这个任务的任何信息，直到我们调用恢复任务的API函数；而任务处于阻塞态的时候，系统还需要判断阻塞态的任务是否超时，是否可以解除阻塞。

2. 你知道那些实时操作系统的调度算法

3. 抢占式调度算法，时间片轮转调度算法

4. FreeRTOS中的任务优先级是如何设置的？

   1. 配置文件中有一个最大优先级，推荐使用第四种优先级分组，也就是4bit抢占优先级，0bit响应优先级
   2. 创建任务时会让指定一个任务优先级
   3. 使用`vTaskPrioritySet` 来设置任务的优先级

5. FreeRTOS中的任务延迟是如何实现的？

   1. 通过调用vTaskDelay函数，进入阻塞状态，实现延时

6. FreeRTOS中实现任务间的消息传递？

7. FreeRTOS的时间片轮转调度是如何工作的？

8. 什么是任务控制块（TCB）？它在FreeRTOS中有什么作用？

   1. 任务控制块是 FreeRTOS 中用于描述和管理任务的[数据结构](https://so.csdn.net/so/search?q=数据结构&spm=1001.2101.3001.7020)，包含了任务的状态、优先级、堆栈等信息。全称为Task Control Block，也就是任务控制块，这个结构体包含了一个任务所有的信息例如：任务名称、任务优先级、栈顶指针

9. FreeRTOS中的任务优先级反转问题是什么？如何解决？

10. FreeRTOS的堆管理机制是怎样的？

11. 在FreeRTOS中，如何实现任务的挂起和恢复？

    1. 调用vTaskSuspend()函数实现挂起

       1. 根据任务句柄获得任务控制块，如果句柄为NULL，则挂起自身
       2. 将要挂起的任务从相应的状态列表和事件列表中移除
       3. 将待挂起任务的任务状态列表向插入到挂起态任务列表末尾
       4. 判断任务调度器是否运行，在运行，更新下一次阻塞时间，防止被挂起任务为下一 次阻塞超时任务
       5. 、如果挂起的是任务自身，且调度器正在运行，需要进行一次任务切换（触发PendSV切换）
       6. 调度器没有运行，判断挂起任务数是否等于任务总数，是：当前控制块赋值为NULL， 否：寻找下一个最高优先级任务

    2. vTaskResume( )实现恢复任务

       1. 需将宏INCLUDE_vTaskSuspend 配置为 1

       1. 恢复任务不能是正在运行任务

       1. 判断任务是否在挂起列表中，是：就会将该任务在挂起列表中移除， 将该任务添加到就绪列表中

       1. 判断恢复的任务优先级是否大于当前正在运行的 是的话执行任务切换

12. FreeRTOS中如何使用信号量？信号量的类型有哪些？

13. FreeRTOS的队列机制是如何工作的？它有哪些应用场景？

14. FreeRTOS中的软件定时器是如何实现的？

15. 如何在FreeRTOS中处理任务间的共享资源？

16. FreeRTOS支持哪些类型的中断？中断处理的基本原则是什么？

    1. FreeRTOS开关中断就是操作 BASEPRI 寄存器实现的，它可以关闭低于某个阈值的中断，高于阈值的中断不会被关闭。

    1. **内部中断**，即任务与内核之间进行的，如`SysTick`中断、`SVC`中断和`PendSV`中断；**外部中断**，`FreeRTOS`对外部事件的响应，如按键状态获取、传感器中断信号等

    1. 先响应高优先级中断，中断处理函数要快速执行完毕

17. FreeRTOS的内存保护机制是如何实现的？

18. FreeRTOS中的任务堆栈溢出检测是如何工作的？

19. FreeRTOS中如何实现定时任务？

20. FreeRTOS的配置文件中，configUSE_PREEMPTION和configUSE_IDLE_HOOK的作用是什么？

21. FreeRTOS中的任务状态转换图是怎样的？

22. FreeRTOS的任务通知机制是什么？如何使用？

23. FreeRTOS如何处理异常和错误？

24. 在FreeRTOS中，如何实现多核处理？

25. FreeRTOS的任务调度是如何影响系统性能的？

26. 如何在FreeRTOS中实现低功耗模式？

27. FreeRTOS的移植过程通常需要考虑哪些硬件特性？

28. FreeRTOS的API函数有哪些常用的错误处理机制？

29. FreeRTOS中如何实现动态任务创建和删除？

30. FreeRTOS的内存分配策略是什么？

31. FreeRTOS如何与其他操作系统进行集成？

32. FreeRTOS的调试工具和方法有哪些？

33. FreeRTOS的任务调度简述

    1. 任务调度
       1. 启动第一个任务
       2. 启动任务调度器：vTaskStartScheduler
       3. 创建空闲任务：prvIdleTask；创建软件定时器任务：xTimerCreateTimerTask
       4. 关中断（在启动第一个任务时开启）；初始化一些全局变量；初始化任务运行时间统计功能的时基定时器
       5. 调用函数xPortStartScheduler完成启动任务调度器
    2. 任务切换流程
       1. 触发任务切换：滴答定时器中断触发PendSV中断或调用FreeRTOS的API函数触发，如：portYIELD( )
       2. 当前的psp是正在运行的任务的栈指针，读取当前psp进程指针，存入r0
       3. 压栈（保存现场）
       4. 获取当前最高优先级任务的任务控制块
       5. 出栈（恢复现场）
       6. 更新切换后的任务的的栈指针给PSP
       7. bx r14 执行新任务函数